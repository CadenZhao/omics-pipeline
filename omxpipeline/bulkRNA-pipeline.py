#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Sun Jul 21 2019

@author: Xiangjie Zhao
@email: xjzhao@genetics.ac.cn

A pipeline for bulk RNA-seq analysis
"""

# --------------------------------------------------
# module, compatibility

from __future__ import (division, print_function, absolute_import, unicode_literals)
from os.path import join as join_path
from datetime import datetime

import os, subprocess
import argparse

try:
    from future_builtins import ascii, filter, hex, map, oct, zip
except:
    pass

if os.sys.version_info.major > 2:
    xrange = range
    
# --------------------------------------------------
# utils

class OmicsException(Exception):
    """custom exception
    """
    pass


def parser():
    """parse arguments
    return:
        parsed arguments
    """
    # generate subparser object
    argparser = argparse.ArgumentParser(description='Description: this program is used to perform bulk RNA-seq pipeline')
    commands = argparser.add_subparsers(dest='command', title='Subcommands')

    # 1. transcriptome-based mode
    tmode_command = commands.add_parser('tMode', help='Perform transcriptome-based bulkRNA-seq pipeline', description='Perform transcriptome-based bulkRNA-seq pipeline. (Reference transcriptome will be used)')
    tmode_command.add_argument('-t', '--transcriptome_fasta', metavar='transcriptome.fa', type=str, required=True, help='transcriptome fasta file')

    # 2. genome-based mode
    gmode_command = commands.add_parser('gMode', help='Perform genome-based bulkRNA-seq pipelin', description='Perform genome-based bulkRNA-seq pipeline. (Reconstructed transcriptome will be used)')
    group = gmode_command.add_mutually_exclusive_group()
    group.add_argument('-g', '--genome_index', metavar='<STAR index>', type=str, required=False, help='genome star index directory. It is generated by STAR --runMode genomeGenerate')
    group.add_argument('-G', '--genome_fasta', metavar='<genome.fa>', type=str, required=False, help='genome fasta file. It will be ignored if -g be assigned and STAR index is exting')
    gmode_command.add_argument('-a', '--annot', metavar='<ref.gtf>', type=str, required=True, help='annotation GTF file. It should not be a compressed file')
    gmode_command.add_argument('-i', '--in_fq_dir', metavar='<fastq directory>', type=str, required=True, help='input fastq file directory. All file should be compressed with suffix .fastq.gz')
    gmode_command.add_argument('-o', '--out_dir', metavar='<output directory>', type=str, required=True, help='output directory')
    gmode_command.add_argument('-t', '--type_of_lib', metavar='<SE or PE>', choices=['SE','PE'], type=str, required=True, help='type of library (SE for single end or PE for paired end)')
    gmode_command.add_argument('-d', '--adaptor_dir', metavar='<adaptor directory>', type=str, required=True, help='illumina Hiseq series sequencing platform adaptor directory, may be <path to trimmomatic>/adaptors. if you installed trimmomatic by conda, it may be: <path to anaconda installed directory>/envs/<environment name>/share/trimmomatic/adapters/')
    # optional parameters
    gmode_command.add_argument('-@', '--thread', metavar='<threads>', type=int, default=8, help='number of threads. Default: 8')
    gmode_command.add_argument('-l', '--read_length', metavar='<read length>', type=int, default=100, help='read max length. Default: 100')
    gmode_command.add_argument('-T', '--trimmomatic', metavar='<path: trimmomatic>', type=str, default='trimmomatic', help='trimmomatic path. Default: trimmmomatic in current environmental variables')
    gmode_command.add_argument('-q', '--fastqc', metavar='<path: fastqc>', type=str, default='fastqc', help='fastqc path. Default: fastqc in current environmental variables')
    gmode_command.add_argument('-Q', '--multiqc', metavar='<path: multiqc>', type=str, default='multiqc', help='multiqc path. Default: multiqc in current environmental variables')
    gmode_command.add_argument('-s', '--STAR', metavar='<path: STAR>', type=str, default='STAR', help='STAR path. Default: STAR in current environmental variables')
    gmode_command.add_argument('-S', '--samtools', metavar='<path: samtools>', type=str, default='samtools', help='samtools path. Default: samtools in current environmental variable')
    gmode_command.add_argument('-r', '--rscript', metavar='<path: Rscript>', type=str, default='Rscript', help='Rscript path. Default: Rscript in current environmental variable')
    
    print('*'*77,'\nRuning parameters: ', ' '.join(os.sys.argv), '\n', '*'*77, sep='')
    if len(os.sys.argv[1:]) == 0:
        argparser.print_help()  # argparser.print_usage() for just the usage line
        argparser.exit(2)
    return argparser.parse_args()


def mkdir(dir_path):
    cmd = r'mkdir -p %s' % dir_path
    subprocess.run(cmd, shell=True, check=True)

def build_index(genome_fasta, annot, thread, read_max_length):
    print("***Using reference genome fasta file to build STAR genome index before aligning...***")
    # make index dir right in the loc dir of fasta file
    genome_index_dir = genome_fasta.rstrip('fa')+'star.index'
    mkdir(genome_index_dir)
    # build STAR index
    cmd = r'STAR --runMode genomeGenerate --genomeFastaFiles %s --sjdbGTFfile %s --genomeDir %s --runThreadN %s --sjdbOverhang %s' % (genome_fasta, annot, genome_index_dir, thread, read_max_length-1)
    subprocess.run(cmd, shell=True, check=True)
    return genome_index_dir
    

def make_outdir_structure(out_dir, structure_list):
    for s in structure_list:
        d = join_path(out_dir,s)
        mkdir(d)
    return [join_path(out_dir,s) for s in structure_list]


def trim_adaptor(lib_type, thread, trim_dir, sample_id, in_fq_dir, adaptor_dir):
    sample_prefix = join_path(in_fq_dir, sample_id)
    cmd_se = r'trimmomatic {0} -threads {1} -phred33 -trimlog {2}.trimmomatic.log {3}.fastq.gz {2}.trimmed.fastq.gz ILLUMINACLIP:{4}/TruSeq3-{0}.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:50 '.format(lib_type, thread, join_path(trim_dir,sample_id), sample_prefix, adaptor_dir)
    cmd_pe = r'trimmomatic {0} -threads {1} -phred33 -trimlog {2}.trimmomatic.log {3}_1.fastq.gz {3}_2.fastq.gz {2}_1.trimmed.fastq.gz {2}_1.abandoned.fastq.gz {2}_2.trimmed.fastq.gz {2}_2.abandoned.fastq.gz ILLUMINACLIP:{4}/TruSeq3-{0}.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:50 '.format(lib_type, thread, join_path(trim_dir,sample_id), sample_prefix, adaptor_dir)
    if lib_type == 'SE':
        subprocess.run(cmd_se, shell=True, check=True)
    elif lib_type == 'PE':
        subprocess.run(cmd_pe, shell=True, check=True)


def qc(fastqc, fastqc_dir, thread, fastq_dir):
    fq_file_list = [join_path(fastq_dir,f) for f in os.listdir(fastq_dir) if f.endswith('.fastq.gz')]
    print(' '.join(fq_file_list))
    # fastqc
    cmd = r'%s -o %s -t %d %s' % (fastqc, fastqc_dir, thread, join_path(fastq_dir,'*.fastq.gz'))
#    cmd = '{0} -o {1} -t {2} {3}'.format(fastqc, fastqc_dir, thread, ' '.join(fq_file_list))
    subprocess.run(cmd, shell=True, check=True)
    

def mqc(multiqc, out_dir, in_dir):
    # multiqc
    cmd = r'%s -o %s %s' % (multiqc, out_dir, in_dir)
    subprocess.run(cmd, shell=True, check=True)

    
def align(STAR, sample_id, type_of_lib, thread, genome_index, trim_dir, align_dir):
    fixed_parameters=r'--quantMode TranscriptomeSAM GeneCounts \
                       --outSAMtype BAM Unsorted \
                       --genomeLoad LoadAndKeep \
                       --outFilterType BySJout \
                       --outSAMattributes NH HI AS NM MD \
                       --outFilterMultimapNmax 20 \
                       --alignSJoverhangMin 8 --alignSJDBoverhangMin 1 \
                       --outFilterMismatchNmax 999 \
                       --alignIntronMin 20 --alignIntronMax 1000000 --alignMatesGapMax 1000000 \
                       --outSAMattrIHstart 0 --outSAMstrandField intronMotif \
                       --outReadsUnmapped Fastx \
                      '
    if type_of_lib == 'SE':
        input_file = '%s.trimmed.fastq.gz' % join_path(trim_dir,sample_id)
    elif type_of_lib == 'SE':
        input_file = '{0}_1.trimmed.fastq.gz {0}_2.trimmed.fastq.gz'.format(join_path(trim_dir,sample_id))
    cmd = r'%s %s --runMode alignReads --runThreadN %d --genomeDir %s --readFilesIn %s --readFilesCommand zcat --outFileNamePrefix %s.' % (STAR, fixed_parameters, thread, genome_index, input_file, join_path(align_dir,sample_id,sample_id))   

    mkdir(join_path(align_dir, sample_id))
    subprocess.run(cmd, shell=True, check=True)
    
    
def sort_bam(samtools, thread, align_dir, sample_id):
    cmd_sort = r'{0} sort -@ {1} -o {2}.Aligned.out.sorted.bam -T {2} {2}.Aligned.out.bam'.format(samtools, thread, join_path(align_dir,sample_id,sample_id))
    cmd_index = r'%s index -@ %d %s.Aligned.out.sorted.bam' % (samtools, thread, join_path(align_dir, sample_id,sample_id))
    subprocess.run(cmd_sort, shell=True, check=True)
    subprocess.run(cmd_index, shell=True, check=True)


def format_count(align_dir, sample_id):
    sample_prefix = join_path(align_dir,sample_id,sample_id)
#    with open('{}.ReadsPerGene.out.tab'.format(sample_prefix), 'r') as f:
#        count = f.readlines()[4:]
#    with open('.'.join([sample_prefix,'ReadsPerGene.out.formatted.tsv']), 'w') as f:
#        count.insert(0, 'ensembl_id\t{0}\t{0}_sense\t{0}_antisense\n'.format(sample_id))
#        f.writelines(count)
    cmd = r'tail -n +5 {0}.ReadsPerGene.out.tab | sed "1 i\ensembl_id\t{1}\t${1}_sense\t${1}_antisense" - > {0}.ReadsPerGene.out.formatted.tsv'.format(sample_prefix, sample_id)
    subprocess.run(cmd, shell=True, check=True)


def merge_count(align_dir, quant_dir):
    cmd = r"""paste `find %s  -name "*.formatted.tsv"` | awk 'BEGIN{FS=OFS="\t"} {line=$1; for (i=2;i<NF;i+=4) line=line"\t"$i; print line}' - > %s""" % (align_dir,join_path(quant_dir, 'star.ReadsPerGene.out.formatted.merged.tsv'))
    subprocess.run(cmd, shell=True, check=True)
    

def count2TPM(rscript, annot, quant_dir):
    gtf_prefix = os.path.basename(annot).rstrip('.gtf')
    annot_file = join_path(quant_dir,gtf_prefix)+'.gene.anno.bed'
    current_dir = os.path.dirname(os.path.realpath(__file__))

    cmd_annot = r"""cat %s | grep -P "\tgene\t" | awk 'BEGIN{FS="[\t; ]"; OFS="\t"; printf "chromosome\tstart\tend\tensembl_id\tstrand\thgnc_symbol\tgene_biotype\n"} {gsub(/"/,"",$10); gsub(/"/,"",$16); gsub(/"/,"",$22); print $1,$4,$5+1,$10,$7,$16,$22}' > %s""" % (annot, annot_file)
    subprocess.run(cmd_annot, shell=True, check=True)

#    # extract gene annotation info from GTF
#    data = pd.read_csv(annot, sep='\t', skiprows=5, low_memory=False, header=None)
#    data = data[data.iloc[:,2] == 'gene']
#    data = data.iloc[:,[0,3,4,6,8]]
#    data.iloc[:,2] = data.iloc[:,2].astype(int) + 1
#    d = data.iloc[:,4].str.split('[\s;"]', expand=True)
#    data = pd.concat([data.iloc[:,[0,1,2]], d.iloc[:,2], data.iloc[:,3], d.iloc[:,12], d.iloc[:,22]], axis=1)
#    data.columns = ['chromosome', 'start', 'end', 'ensembl_id', 'strand', 'hgnc_symbol', 'gene_biotype']
#    data.to_csv(annot_file, index=False, sep='\t')

    cmd_c2t = r'%s %s %s %s %s %s' % (rscript, join_path(current_dir,'r','exon.length.per.gene.R'), annot, annot_file, join_path(quant_dir, 'star.ReadsPerGene.out.formatted.merged.tsv'), join_path(quant_dir, 'tpm.gene.tsv'))
    subprocess.run(cmd_c2t, shell=True, check=True)


# --------------------------------------------------
# pipeline

def main():
    START_TIME = datetime.now()
    args=parser()
    
    # -----------------------
    
    if args.command == 'tMode':
        pass

    elif args.command == 'gMode':
        # arguments
        (genome_index, genome_fasta, annot, in_fq_dir, out_dir, type_of_lib, adaptor_dir, 
         thread, read_length, trimmmomatic, fastqc, multiqc, STAR, samtools, Rscript
        ) = (args.genome_index, args.genome_fasta, args.annot, args.in_fq_dir, args.out_dir, args.type_of_lib, args.adaptor_dir,
             args.thread, args.read_length, args.trimmomatic, args.fastqc, args.multiqc, args.STAR, args.samtools, args.rscript
            )
        if type_of_lib == 'SE':
            sample_ids = [f.rstrip('.fastq.gz') for f in os.listdir(in_fq_dir) if f.endswith('.fastq.gz')]
        else:
            sample_ids= [f.rstrip('_1.fastq.gz') for f in os.listdir(in_fq_dir) if f.endswith('_1.fastq.gz')]
            
        # check if -g or -G at least one exist
        if genome_index == None and genome_fasta == None:
            os.sys.exit('ERROR: -g or -G must be set.  Please set at least one')

        # 0. build STAR index
        if genome_fasta is not None:
            genome_index = build_index(genome_fasta, annot, thread, read_length)

        # 1. custome outdir structure
        structure_list = ['fastq_trimmed', 'qc/fastqc', 'qc/multiqc', 'qc/multiqc/fastqc_report',
                          'qc/multiqc/star_report','alignment/star', 'quantification']
        trim_dir, fastqc_dir, multiqc_dir, multiqc_fastqc_report, multiqc_star_report, align_dir, quant_dir = make_outdir_structure(out_dir, structure_list)
        
        # 2. trime adaptor and filter low quality sequences
        if thread > 64:
            print('Number of threads is to large for Timmomatic, will use 64 threads')
            thread_trim = 64
        else:
            thread_trim = thread
        for sample_id in sample_ids:
            trim_adaptor(type_of_lib, thread_trim, trim_dir, sample_id, in_fq_dir, adaptor_dir)
         
        # 3. fastqc for raw and trimmed FASTQ
        qc(fastqc, fastqc_dir, thread, in_fq_dir)
        qc(fastqc, fastqc_dir, thread, trim_dir)

        # 4. multiqc for fastqc results
        mqc(multiqc, multiqc_fastqc_report, fastqc_dir)
         
        # 5. align reads to genome
        for sample_id in sample_ids:
            align(STAR, sample_id, type_of_lib, thread, genome_index, trim_dir, align_dir)
            format_count(align_dir, sample_id)
        
        # 6. sort and index BAM
        for sample_id in sample_ids:
            sort_bam(samtools, thread, align_dir, sample_id)
 
        # 7. format, merge count
        merge_count(align_dir, quant_dir)
            
        # 8. count to TPM while adding gene annotation
        count2TPM(Rscript, annot, quant_dir)
        
        print('OK!  The whole pipeline done!')

    # ---------------------- 
    
    elasped_time = datetime.now() - START_TIME
    os.sys.stderr.write("** Pipeline run time: %d seconds **\n" % (elasped_time.seconds))


if __name__ == '__main__':
    main()




 
